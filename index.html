<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin from First Principles - Interactive Tutorial</title>
    <script src="https://cdn.tailwindcss.com" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js" defer></script>
    <style>
        :root { 
            color-scheme: light dark; 
            --brand-orange: #f7931a;
            --brand-orange-light: #ffb347;
        }
        
        html.dark body { background:#0b0b0b; }
        html.dark .header-bg { background: linear-gradient(135deg, #0a0a0a 0%, #111 50%, #1a1a1a 100%); }
        html.dark .bg-white { background:#111 !important; }
        html.dark .text-gray-700 { color:#d1d5db !important; }
        html.dark .text-gray-600 { color:#9ca3af !important; }
        html.dark .text-gray-500 { color:#6b7280 !important; }
        html.dark .bg-gray-50 { background:#0f1115 !important; }
        html.dark .border { border-color:#262626 !important; }
        html.dark .hover\:bg-gray-50:hover { background:#1a1a1a !important; }
        
        .brand-gradient-text {
            background: linear-gradient(45deg, var(--brand-orange), var(--brand-orange-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .brand-orange { color: var(--brand-orange); }
        
        .quiz-option {
            transition: all 0.2s;
            cursor: pointer;
        }
        
        .quiz-option:hover {
            transform: translateY(-1px);
        }
        
        .quiz-option.correct {
            background-color: #10b981;
            color: white;
            border-color: #059669;
        }
        
        .quiz-option.incorrect {
            background-color: #ef4444;
            color: white;
            border-color: #dc2626;
        }
        
        .interactive-demo {
            border-left: 4px solid var(--brand-orange);
        }
        
        .progress-bar {
            background: linear-gradient(90deg, var(--brand-orange), var(--brand-orange-light));
            height: 8px;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        /* Global focus ring */
        :where(button, [role="button"], input, a):focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(255,140,0,.45);
            border-radius: 8px;
        }
    </style>
</head>
<body class="bg-gray-100">
    <header class="header-bg bg-gradient-to-br from-orange-600 to-orange-800 text-white py-12">
        <div class="flex justify-end max-w-6xl mx-auto px-6">
            <button id="theme-toggle" class="mt-2 inline-flex items-center gap-2 rounded-lg px-3 py-2 bg-white/10 hover:bg-white/20 text-white text-sm">
                <span id="theme-label">Dark</span>
                <svg class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="5"></circle>
                    <path d="M12 1v2m0 18v2m11-11h-2M3 12H1m16.95 6.95-1.41-1.41M6.46 6.46 5.05 5.05m13.9 0-1.41 1.41M6.46 17.54 5.05 18.95"/>
                </svg>
            </button>
        </div>
        
        <div class="max-w-6xl mx-auto px-6">
            <h1 class="text-5xl font-bold mb-4">Bitcoin from First Principles</h1>
            <p class="text-xl mb-8 text-orange-100">An interactive, Socratic exploration of how Bitcoin works</p>
            
            <!-- Progress Bar -->
            <div class="bg-white/20 rounded-full p-1">
                <div id="progress-bar" class="progress-bar w-0"></div>
            </div>
            <p id="progress-text" class="text-sm mt-2 text-orange-100">0 of 11 Principles Understood</p>
        </div>
    </header>

    <main class="max-w-6xl mx-auto px-6 py-12">
        <!-- Principle 1: Digital Money Problem -->
        <section id="principle-1" class="principle-section mb-20">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-4xl font-bold mb-6 brand-gradient-text">The Digital Money Problem</h2>
                <p class="text-gray-700 text-lg mb-6">
                    Digital files can be copied infinitely. How do we prevent digital money from being spent twice without a central authority?
                </p>

                <div class="interactive-demo bg-gray-50 p-6 rounded-lg mb-6">
                    <h4 class="text-lg font-semibold mb-4">Double-Spend Demo</h4>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="text-center">
                            <div class="bg-white p-4 rounded border">
                                <h5 class="font-medium mb-2">Alice's Balance: 1 BTC</h5>
                                <button id="send-to-bob" class="quiz-option bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600" role="button" tabindex="0">
                                    Send 1 BTC to Bob
                                </button>
                            </div>
                        </div>
                        <div class="text-center">
                            <div class="bg-white p-4 rounded border">
                                <h5 class="font-medium mb-2">Alice's Balance: 1 BTC</h5>
                                <button id="send-to-charlie" class="quiz-option bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600" role="button" tabindex="0">
                                    Send 1 BTC to Charlie
                                </button>
                            </div>
                        </div>
                    </div>
                    <div id="double-spend-result" class="mt-4 text-center font-medium"></div>
                    <p class="mt-3 text-xs text-gray-500">Illustrative demo showing the double-spend problem in digital systems.</p>
                </div>

                <div class="quiz-section">
                    <h4 class="text-lg font-semibold mb-4">Check Your Understanding</h4>
                    <p class="mb-4">Why can't we just copy Bitcoin like other digital files?</p>
                    <div class="grid gap-3">
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Because Bitcoin files are encrypted
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="true" role="button" tabindex="0">
                            Because the network tracks ownership and prevents double-spending
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Because Bitcoin is stored on special hardware
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Principle 2: Blockchain Structure -->
        <section id="principle-2" class="principle-section mb-20">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-4xl font-bold mb-6 brand-gradient-text">Blockchain Structure</h2>
                <p class="text-gray-700 text-lg mb-6">
                    Transactions are grouped into blocks, and each block references the previous one, creating a chain that's extremely difficult to alter.
                </p>

                <div class="interactive-demo bg-gray-50 p-6 rounded-lg mb-6">
                    <h4 class="text-lg font-semibold mb-4">Blockchain Tamper Test</h4>
                    <div class="space-y-4">
                        <div class="flex items-center space-x-4 p-4 bg-white rounded border">
                            <div class="w-16 h-16 bg-blue-500 rounded flex items-center justify-center text-white font-bold">
                                Block 1
                            </div>
                            <div class="text-sm">
                                <div>Hash: <span class="font-mono text-xs">000abc123...</span></div>
                                <div>Prev Hash: <span class="font-mono text-xs">000000000...</span></div>
                                <input id="block1-data" type="text" value="Alice sends 1 BTC to Bob" class="mt-1 w-full border px-2 py-1 rounded text-xs">
                            </div>
                        </div>
                        <div class="flex items-center space-x-4 p-4 bg-white rounded border">
                            <div class="w-16 h-16 bg-blue-500 rounded flex items-center justify-center text-white font-bold">
                                Block 2
                            </div>
                            <div class="text-sm">
                                <div>Hash: <span class="font-mono text-xs">000def456...</span></div>
                                <div>Prev Hash: <span class="font-mono text-xs">000abc123...</span></div>
                                <div class="mt-1 text-xs">Bob sends 0.5 BTC to Charlie</div>
                            </div>
                        </div>
                        <button id="tamper-test" class="quiz-option bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">
                            Try to Change Block 1 Data
                        </button>
                        <div id="tamper-result" class="text-sm font-medium"></div>
                    </div>
                    <p class="mt-3 text-xs text-gray-500">Illustrative model showing how changing past data breaks the chain.</p>
                </div>

                <div class="quiz-section">
                    <h4 class="text-lg font-semibold mb-4">Check Your Understanding</h4>
                    <p class="mb-4">What happens when someone tries to change a transaction in an old block?</p>
                    <div class="grid gap-3">
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Nothing, the change goes through
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="true" role="button" tabindex="0">
                            The hash changes, breaking the chain and alerting the network
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Only the block author can make changes
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Principle 3: Mempool & Fee Market -->
        <section id="principle-3" class="principle-section mb-20">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-4xl font-bold mb-6 brand-gradient-text">Mempool & Fee Market</h2>
                <p class="text-gray-700 text-lg mb-6">
                    Before transactions get into blocks, they wait in the mempool. Miners prioritize transactions with higher fees, creating a market for block space.
                </p>

                <div class="interactive-demo bg-gray-50 p-6 rounded-lg mb-6">
                    <h4 class="text-lg font-semibold mb-4">Fee Market Simulator</h4>
                    
                    <div class="grid md:grid-cols-2 gap-6">
                        <div>
                            <label class="block text-sm font-medium mb-2">Your fee rate (sat/vB)
                                <input id="fee-satvb" type="range" min="1" max="200" value="10" class="w-full mt-1">
                                <div class="text-center text-sm text-gray-600 mt-1">
                                    <span id="fee-display">10</span> sat/vB
                                </div>
                            </label>
                            
                            <label class="block text-sm font-medium mt-4 mb-2">Network congestion
                                <input id="fee-load" type="range" min="0" max="100" value="60" class="w-full mt-1">
                                <div class="text-center text-sm text-gray-600 mt-1">
                                    <span id="load-display">60</span>% full blocks
                                </div>
                            </label>
                        </div>
                        
                        <div class="grid grid-cols-1 gap-4">
                            <div class="text-center p-4 bg-white rounded border">
                                <div class="text-2xl font-bold brand-orange" id="fee-eta">~3 blocks</div>
                                <div class="text-sm text-gray-600">Estimated confirmation time</div>
                            </div>
                            <div class="text-center p-4 bg-white rounded border">
                                <div class="text-2xl font-bold brand-orange" id="fee-priority">Medium</div>
                                <div class="text-sm text-gray-600">Priority level</div>
                            </div>
                            <div class="text-center p-4 bg-white rounded border">
                                <div class="text-2xl font-bold brand-orange" id="fee-percentile">~70th</div>
                                <div class="text-sm text-gray-600">Mempool percentile</div>
                            </div>
                        </div>
                    </div>

                    <p class="mt-4 text-xs text-gray-500">Illustrative model—not live fee estimates. Actual confirmation times depend on network conditions.</p>
                </div>

                <div class="quiz-section">
                    <h4 class="text-lg font-semibold mb-4">Check Your Understanding</h4>
                    <p class="mb-4">Why do some Bitcoin transactions confirm faster than others?</p>
                    <div class="grid gap-3">
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Larger transactions are processed first
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="true" role="button" tabindex="0">
                            Miners prioritize transactions with higher fee rates
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Transactions from verified accounts go first
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Principle 8: Lightning Routing & Liquidity -->
        <section id="principle-8-lightning" class="principle-section mb-20">
          <div class="bg-white rounded-lg shadow-lg p-8 max-w-6xl mx-auto">
            <h2 class="text-4xl font-bold mb-6 brand-gradient-text">Lightning: Routing & Liquidity</h2>

            <p class="text-gray-700 mb-4">
              Lightning payments travel across channels with limited capacity and directional liquidity. This demo shows why a route may succeed or fail depending on fees, capacity, and path availability.
            </p>

            <div class="interactive-demo bg-gray-50 p-6">
              <!-- Controls -->
              <div class="grid md:grid-cols-2 gap-6">
                <div class="bg-white p-4 rounded border">
                  <h5 class="font-semibold mb-2">Payment Parameters</h5>
                  <div class="space-y-3 text-sm">
                    <label class="block">Amount (sats)
                      <input id="ln-amount" type="number" value="15000" min="1" step="1" class="w-full border rounded px-2 py-1 mt-1">
                    </label>
                    <label class="block">Max Total Fee (sats)
                      <input id="ln-maxfee" type="number" value="50" min="0" step="1" class="w-full border rounded px-2 py-1 mt-1">
                    </label>
                    <label class="block">Try Alt Paths
                      <input id="ln-try-alt" type="checkbox" class="ml-2 align-middle">
                    </label>
                  </div>
                  <button id="ln-send" class="mt-4 brand-gradient hover:opacity-90 text-white px-4 py-2 rounded font-semibold">
                    Find Route & Send
                  </button>
                  <p class="mt-2 text-xs text-gray-500">Illustrative only—this is not a real wallet or network.</p>
                </div>

                <!-- Graph -->
                <div class="bg-white p-4 rounded border">
                  <h5 class="font-semibold mb-2">Channel Graph (Toy)</h5>
                  <div class="text-xs text-gray-600 mb-2">Node balances are directional. Each edge shows <em>local → remote</em> capacity.</div>

                  <div id="ln-graph" class="grid grid-cols-3 gap-3">
                    <!-- A, B, C on row 1 -->
                    <div class="text-center">
                      <div class="w-12 h-12 rounded-full bg-blue-500 text-white mx-auto flex items-center justify-center font-bold">A</div>
                      <div class="text-xs mt-1">Alice (sender)</div>
                    </div>
                    <div class="text-center">
                      <div class="w-12 h-12 rounded-full bg-blue-500 text-white mx-auto flex items-center justify-center font-bold">B</div>
                      <div class="text-xs mt-1">Bob</div>
                    </div>
                    <div class="text-center">
                      <div class="w-12 h-12 rounded-full bg-blue-500 text-white mx-auto flex items-center justify-center font-bold">C</div>
                      <div class="text-xs mt-1">Carol</div>
                    </div>
                    <!-- D, E, F on row 2 -->
                    <div class="text-center">
                      <div class="w-12 h-12 rounded-full bg-blue-500 text-white mx-auto flex items-center justify-center font-bold">D</div>
                      <div class="text-xs mt-1">Dan</div>
                    </div>
                    <div class="text-center">
                      <div class="w-12 h-12 rounded-full bg-green-600 text-white mx-auto flex items-center justify-center font-bold">R</div>
                      <div class="text-xs mt-1">Rita (receiver)</div>
                    </div>
                    <div class="text-center">
                      <div class="w-12 h-12 rounded-full bg-blue-500 text-white mx-auto flex items-center justify-center font-bold">F</div>
                      <div class="text-xs mt-1">Frank</div>
                    </div>
                  </div>

                  <!-- Edge list for readability -->
                  <div class="mt-4">
                    <h6 class="font-semibold text-sm mb-1">Channels (local → remote capacity / base+ppm fee)</h6>
                    <ul class="text-xs space-y-1 text-gray-700" id="ln-edges">
                      <!-- will be filled by script -->
                    </ul>
                  </div>
                </div>
              </div>

              <!-- Result -->
              <div id="ln-result" class="mt-6 hidden">
                <div class="p-4 rounded border-l-4" id="ln-result-box">
                  <div class="font-semibold mb-1" id="ln-result-title"></div>
                  <div class="text-sm" id="ln-result-body"></div>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Principle 4: UTXO Model -->
        <section id="principle-4" class="principle-section mb-20">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-4xl font-bold mb-6 brand-gradient-text">UTXO Model</h2>
                <p class="text-gray-700 text-lg mb-6">
                    Bitcoin doesn't track balances like a bank account. Instead, your "balance" is a collection of unspent transaction outputs (UTXOs) - like digital coins of different denominations.
                </p>

                <div class="interactive-demo bg-gray-50 p-6 rounded-lg mb-6">
                    <h4 class="text-lg font-semibold mb-4">UTXO Builder</h4>
                    <p class="text-sm text-gray-600 mb-4">Select UTXOs to spend and see how change is calculated:</p>
                    
                    <div id="utxo-list" class="grid md:grid-cols-3 gap-3 mb-6"></div>

                    <div class="bg-white p-4 rounded border">
                        <div class="space-y-2 text-sm">
                            <div class="flex justify-between">
                                <span>Selected Inputs Total:</span>
                                <span id="utxo-input-sum" class="font-semibold font-mono">0.00000000 ₿</span>
                            </div>
                            <div class="flex justify-between items-center">
                                <span>Send Amount:</span>
                                <span>
                                    <input id="utxo-send" type="number" step="0.00000001" value="0.00100000" 
                                           class="w-32 border px-2 py-1 rounded text-right font-mono text-xs">
                                    <span class="ml-1">₿</span>
                                </span>
                            </div>
                            <div class="flex justify-between">
                                <span>Estimated Fee (20 sat/vB):</span>
                                <span id="utxo-fee" class="font-semibold font-mono">0.00000500 ₿</span>
                            </div>
                            <hr class="my-3">
                            <div class="flex justify-between font-medium">
                                <span>Change Output:</span>
                                <span id="utxo-change" class="font-semibold font-mono brand-orange">0.00000000 ₿</span>
                            </div>
                            <div id="utxo-error" class="text-red-600 text-xs mt-2"></div>
                        </div>
                    </div>

                    <p class="mt-4 text-xs text-gray-500">Illustrative only; not a real wallet. Shows why Bitcoin transactions often need "change" outputs.</p>
                </div>

                <div class="quiz-section">
                    <h4 class="text-lg font-semibold mb-4">Check Your Understanding</h4>
                    <p class="mb-4">Why do Bitcoin transactions often have a "change" output?</p>
                    <div class="grid gap-3">
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            To pay transaction fees to miners
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="true" role="button" tabindex="0">
                            Because UTXOs must be spent completely, excess goes back as change
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            To keep transactions private
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Principle 5: Proof of Work -->
        <section id="principle-5" class="principle-section mb-20">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-4xl font-bold mb-6 brand-gradient-text">Proof of Work</h2>
                <p class="text-gray-700 text-lg mb-6">
                    Miners compete to solve computational puzzles. This "proof of work" secures the network by making attacks extremely expensive.
                </p>

                <div class="interactive-demo bg-gray-50 p-6 rounded-lg mb-6">
                    <h4 class="text-lg font-semibold mb-4">Mining Simulation</h4>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div>
                            <p class="text-sm mb-2">Block Data: "Alice → Bob: 1 BTC"</p>
                            <p class="text-sm mb-4">Find a nonce that makes the hash start with zeros:</p>
                            <div class="space-y-2">
                                <div class="text-xs font-mono bg-white p-2 rounded border">
                                    Nonce: <span id="mining-nonce">0</span>
                                </div>
                                <div class="text-xs font-mono bg-white p-2 rounded border">
                                    Hash: <span id="mining-hash">calculating...</span>
                                </div>
                            </div>
                            <button id="mine-button" class="mt-4 quiz-option bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600">
                                Start Mining
                            </button>
                        </div>
                        <div>
                            <div class="text-center">
                                <div class="text-3xl font-bold brand-orange" id="hash-attempts">0</div>
                                <div class="text-sm text-gray-600">Hash attempts</div>
                                <div class="text-2xl font-bold mt-4 brand-orange" id="mining-time">0.0s</div>
                                <div class="text-sm text-gray-600">Time elapsed</div>
                            </div>
                        </div>
                    </div>
                    <p class="mt-4 text-xs text-gray-500">Simplified mining demo. Real Bitcoin mining requires finding hashes with many more leading zeros.</p>
                </div>

                <div class="quiz-section">
                    <h4 class="text-lg font-semibold mb-4">Check Your Understanding</h4>
                    <p class="mb-4">What makes Bitcoin secure against attacks?</p>
                    <div class="grid gap-3">
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Strong passwords and encryption
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="true" role="button" tabindex="0">
                            The enormous computational cost of rewriting the blockchain
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Government regulation and oversight
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Principle 5.5: Merkle Trees & SPV -->
        <section id="principle-5-merkles" class="principle-section mb-20">
          <div class="bg-white rounded-lg shadow-lg p-8 max-w-6xl mx-auto">
            <h2 class="text-4xl font-bold mb-6 brand-gradient-text">Merkle Trees & SPV</h2>
            <p class="text-gray-700 mb-4">
              Bitcoin compresses many transactions into a single <em>Merkle root</em>. With a short proof (hash siblings along the path) a lightweight client can verify a transaction is inside a block without downloading everything.
            </p>

            <div class="interactive-demo bg-gray-50 p-6">
              <div class="grid md:grid-cols-3 gap-6">
                <!-- Transactions -->
                <div class="bg-white p-4 rounded border">
                  <h5 class="font-semibold mb-2">Transactions (Toy)</h5>
                  <ul id="merkle-txs" class="text-xs space-y-2"></ul>
                  <button id="merkle-shuffle" class="mt-3 bg-gray-200 hover:bg-gray-300 text-gray-800 px-3 py-1 rounded text-sm">Shuffle</button>
                </div>

                <!-- Tree -->
                <div class="bg-white p-4 rounded border">
                  <h5 class="font-semibold mb-2">Tree</h5>
                  <div id="merkle-tree" class="space-y-3 text-xs"></div>
                </div>

                <!-- Proof -->
                <div class="bg-white p-4 rounded border">
                  <h5 class="font-semibold mb-2">Proof</h5>
                  <div class="text-sm mb-2">Click a transaction on the left to build a proof</div>
                  <div id="merkle-proof" class="space-y-2"></div>
                  <div id="merkle-verify" class="mt-3 text-sm font-semibold"></div>
                </div>
              </div>
              <p class="mt-3 text-xs text-gray-500">Hashes are simulated for teaching. Real Bitcoin uses double SHA-256 and specific byte orders.</p>
            </div>
          </div>
        </section>

        <!-- Principle 6: Network Consensus -->
        <section id="principle-6" class="principle-section mb-20">
            <div class="bg-white rounded-lg shadow-lg p-8">
                <h2 class="text-4xl font-bold mb-6 brand-gradient-text">Network Consensus</h2>
                <p class="text-gray-700 text-lg mb-6">
                    Bitcoin operates without central control. The network agrees on the valid chain through consensus rules that all participants follow.
                </p>

                <div class="quiz-section">
                    <h4 class="text-lg font-semibold mb-4">Check Your Understanding</h4>
                    <p class="mb-4">How does Bitcoin achieve consensus without a central authority?</p>
                    <div class="grid gap-3">
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            A democratic vote by all users
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="true" role="button" tabindex="0">
                            Nodes follow the longest valid chain with the most proof of work
                        </button>
                        <button class="quiz-option text-left p-4 border rounded-lg hover:bg-gray-50" data-correct="false" role="button" tabindex="0">
                            Miners decide through majority vote
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Final Progress Summary -->
        <section class="principle-section mb-20">
            <div class="bg-gradient-to-br from-orange-50 to-orange-100 border border-orange-200 rounded-lg p-8 text-center">
                <h2 class="text-3xl font-bold mb-4 brand-gradient-text">Congratulations!</h2>
                <p class="text-gray-700 text-lg mb-6">
                    You've completed the Bitcoin First Principles interactive tutorial. You now understand the core concepts that make Bitcoin work without trust in any central authority.
                </p>
                <div class="grid md:grid-cols-3 gap-6 max-w-3xl mx-auto">
                    <div class="text-center">
                        <div class="text-4xl mb-2">🔗</div>
                        <h4 class="font-semibold">Blockchain Structure</h4>
                        <p class="text-sm text-gray-600">Immutable chain of transactions</p>
                    </div>
                    <div class="text-center">
                        <div class="text-4xl mb-2">⛏️</div>
                        <h4 class="font-semibold">Proof of Work</h4>
                        <p class="text-sm text-gray-600">Computational security model</p>
                    </div>
                    <div class="text-center">
                        <div class="text-4xl mb-2">🌐</div>
                        <h4 class="font-semibold">Decentralized Consensus</h4>
                        <p class="text-sm text-gray-600">No single point of control</p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer class="bg-gray-800 text-white py-8">
        <div class="max-w-6xl mx-auto px-6 text-center">
            <p class="text-gray-300">
                Built with ❤️ for Bitcoin education. 
                <a href="#" class="text-orange-300 hover:text-orange-200">Learn more</a>
            </p>
            <p class="text-xs text-gray-400 mt-2">
                All visualizations and numbers are illustrative for educational purposes unless otherwise noted.
            </p>
        </div>
    </footer>

    <script>
        // Theme toggle functionality
        (function(){
            const key = 'theme_preference';
            const root = document.documentElement;
            const stored = localStorage.getItem(key);
            if(stored === 'dark' || (!stored && window.matchMedia('(prefers-color-scheme: dark)').matches)){
                root.classList.add('dark');
            }
            function setLabel(){
                const label = document.getElementById('theme-label');
                if (label) {
                    label.textContent = root.classList.contains('dark') ? 'Light' : 'Dark';
                }
            }
            document.getElementById('theme-toggle')?.addEventListener('click', ()=>{
                root.classList.toggle('dark');
                localStorage.setItem(key, root.classList.contains('dark') ? 'dark' : 'light');
                setLabel();
            });
            setLabel();
        })();

        // Progress tracking with persistence
        const totalPrinciples = 6;
        const LS_KEY = 'btc_course_progress_v1';
        
        function loadProgress(){ 
            try{ 
                return new Set(JSON.parse(localStorage.getItem(LS_KEY) || '[]')); 
            } catch { 
                return new Set(); 
            } 
        }
        
        function saveProgress(set){ 
            localStorage.setItem(LS_KEY, JSON.stringify([...set])); 
        }
        
        const completedPrinciples = loadProgress();

        function updateProgress(){
            const pct = (completedPrinciples.size/totalPrinciples)*100;
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            
            if (progressBar) progressBar.style.width = pct+'%';
            if (progressText) {
                progressText.textContent = `${completedPrinciples.size} of ${totalPrinciples} Principles Understood`;
            }
            saveProgress(completedPrinciples);
        }

        // Quiz functionality
        function handleQuiz(section) {
            const sectionEl = document.getElementById(section);
            if (!sectionEl) return;
            
            const options = sectionEl.querySelectorAll('.quiz-option[data-correct]');
            let allCorrect = true;
            
            options.forEach(option => {
                option.addEventListener('click', () => {
                    const isCorrect = option.dataset.correct === 'true';
                    
                    // Reset all options in this quiz
                    options.forEach(opt => {
                        opt.classList.remove('correct', 'incorrect');
                        opt.removeAttribute('aria-pressed');
                    });
                    
                    // Mark this option
                    option.classList.add(isCorrect ? 'correct' : 'incorrect');
                    option.setAttribute('aria-pressed', 'true');
                    
                    if (isCorrect) {
                        completedPrinciples.add(section);
                        updateProgress();
                    } else {
                        completedPrinciples.delete(section);
                        updateProgress();
                        allCorrect = false;
                    }
                });
            });
        }

        // Initialize quizzes for all principles
        document.addEventListener('DOMContentLoaded', () => {
            for (let i = 1; i <= totalPrinciples; i++) {
                handleQuiz(`principle-${i}`);
            }
            updateProgress();
        });

        // Keyboard navigation for quizzes
        document.addEventListener('keydown', e=>{
            const btn = document.activeElement;
            if(!btn?.classList?.contains('quiz-option')) return;
            if(e.key==='Enter' || e.key===' '){
                e.preventDefault();
                btn.click();
            }
        });

        // Make quiz options tabbable and accessible
        window.addEventListener('DOMContentLoaded', ()=>{
            document.querySelectorAll('.quiz-option').forEach(b=>{
                if (!b.hasAttribute('role')) {
                    b.setAttribute('role','button');
                }
                if (!b.hasAttribute('tabindex')) {
                    b.setAttribute('tabindex','0');
                }
            });
        });

        // Fee Market Simulator
        (function(){
            const f = id=>document.getElementById(id);
            const fee=f('fee-satvb'), load=f('fee-load'), eta=f('fee-eta'), pri=f('fee-priority'), pct=f('fee-percentile');
            const feeDisplay=f('fee-display'), loadDisplay=f('load-display');
            
            if(!fee||!load) return;
            
            function paint(){
                const sat = +fee.value, l = +load.value;
                
                // Update display values
                if (feeDisplay) feeDisplay.textContent = sat;
                if (loadDisplay) loadDisplay.textContent = l;
                
                // Simple fee market model
                const baseFee = 5 + (l/10); // Base fee increases with congestion
                const ratio = sat/baseFee;
                
                // Calculate blocks to confirmation
                let blocks;
                if (ratio >= 2) blocks = 1;
                else if (ratio >= 1.5) blocks = 2;
                else if (ratio >= 1) blocks = 3;
                else if (ratio >= 0.7) blocks = 6;
                else blocks = Math.min(20, Math.ceil(10/ratio));
                
                // Update displays
                if (eta) eta.textContent = blocks === 1 ? 'next block' : `~${blocks} blocks`;
                if (pri) pri.textContent = ratio >= 1.5 ? 'High' : ratio >= 1 ? 'Medium' : 'Low';
                if (pct) pct.textContent = `~${Math.min(99, Math.max(5, Math.round(ratio * 50)))}th`;
            }
            
            [fee,load].forEach(x=>x.addEventListener('input', paint));
            paint();
        })();

        // UTXO Builder Demo
        (function(){
            const sats = n => (Math.round(n*1e8)/1e8).toFixed(8) + ' ₿';
            const UTXOS = [0.00340000, 0.00210000, 0.00080000, 0.00120000, 0.00500000, 0.00090000];
            const list = document.getElementById('utxo-list');
            const sumEl = document.getElementById('utxo-input-sum');
            const sendEl = document.getElementById('utxo-send');
            const feeEl = document.getElementById('utxo-fee');
            const changeEl = document.getElementById('utxo-change');
            const errorEl = document.getElementById('utxo-error');
            
            if(!list) return;

            const selected = new Set();
            
            function render(){
                list.innerHTML = '';
                UTXOS.forEach((v, i)=>{
                    const div = document.createElement('button');
                    const isSelected = selected.has(i);
                    div.className = `p-3 rounded border text-left transition-all ${
                        isSelected 
                            ? 'bg-green-100 border-green-300 ring-2 ring-green-200' 
                            : 'bg-white hover:bg-gray-50 border-gray-200'
                    }`;
                    div.innerHTML = `
                        <div class="text-sm font-semibold font-mono">${sats(v)}</div>
                        <div class="text-xs text-gray-500">UTXO #${i+1}</div>
                        ${isSelected ? '<div class="text-xs text-green-600 font-medium mt-1">✓ Selected</div>' : ''}
                    `;
                    div.addEventListener('click', ()=>{ 
                        isSelected ? selected.delete(i) : selected.add(i); 
                        calc(); 
                        render(); 
                    });
                    list.appendChild(div);
                });
            }
            
            function calc(){
                const total = [...selected].reduce((a,i)=>a+UTXOS[i],0);
                const send = parseFloat(sendEl.value||0);
                const fee = 0.000005; // 500 sat fixed fee for simplicity
                const change = total - send - fee;
                
                if (sumEl) sumEl.textContent = sats(total);
                if (feeEl) feeEl.textContent = sats(fee);
                if (changeEl) changeEl.textContent = sats(Math.max(0, change));
                
                // Error checking
                let error = '';
                if (selected.size === 0) error = 'Select at least one UTXO to spend';
                else if (total < send + fee) error = 'Insufficient inputs for this transaction';
                else if (change < 0) error = 'Transaction fee too high';
                else if (change > 0 && change < 0.00000546) error = 'Change amount too small (dust)';
                
                if (errorEl) {
                    errorEl.textContent = error;
                    errorEl.style.display = error ? 'block' : 'none';
                }
            }
            
            sendEl?.addEventListener('input', calc);
            render(); 
            calc();
        })();

        // Double spend demo
        (function(){
            const bobBtn = document.getElementById('send-to-bob');
            const charlieBtn = document.getElementById('send-to-charlie');
            const result = document.getElementById('double-spend-result');
            
            if (!bobBtn || !charlieBtn || !result) return;
            
            let sent = [];
            
            function handleSend(recipient, btn) {
                if (sent.length === 0) {
                    sent.push(recipient);
                    btn.textContent = `✓ Sent to ${recipient}`;
                    btn.classList.add('correct');
                    result.textContent = `Transaction sent to ${recipient}. Alice now has 0 BTC.`;
                    result.className = 'mt-4 text-center font-medium text-green-600';
                } else {
                    result.textContent = `❌ Double-spend detected! Alice already sent her 1 BTC to ${sent[0]}. This transaction would be rejected by the network.`;
                    result.className = 'mt-4 text-center font-medium text-red-600';
                    btn.classList.add('incorrect');
                }
            }
            
            bobBtn.addEventListener('click', () => handleSend('Bob', bobBtn));
            charlieBtn.addEventListener('click', () => handleSend('Charlie', charlieBtn));
        })();

        // Blockchain tamper demo
        (function(){
            const tamperBtn = document.getElementById('tamper-test');
            const result = document.getElementById('tamper-result');
            const input = document.getElementById('block1-data');
            
            if (!tamperBtn || !result || !input) return;
            
            tamperBtn.addEventListener('click', () => {
                input.value = "Alice sends 100 BTC to Bob"; // Changed data
                result.innerHTML = `
                    <span class="text-red-600">⚠️ Chain broken!</span><br>
                    Block 1 hash changed to: <span class="font-mono text-xs">000xyz789...</span><br>
                    Block 2's "previous hash" no longer matches!<br>
                    <span class="text-xs text-gray-600">The network would reject this tampered chain.</span>
                `;
            });
        })();

        // Simple mining demo
        (function(){
            const mineBtn = document.getElementById('mine-button');
            const nonceEl = document.getElementById('mining-nonce');
            const hashEl = document.getElementById('mining-hash');
            const attemptsEl = document.getElementById('hash-attempts');
            const timeEl = document.getElementById('mining-time');
            
            if (!mineBtn) return;
            
            let mining = false;
            let startTime, attempts = 0;
            
            // Simple hash function for demo (not cryptographically secure)
            function simpleHash(data) {
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    const char = data.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return Math.abs(hash).toString(16).padStart(8, '0');
            }
            
            function mine() {
                if (!mining) return;
                
                const data = "Alice→Bob:1BTC";
                const nonce = attempts;
                const hash = simpleHash(data + nonce);
                
                if (nonceEl) nonceEl.textContent = nonce;
                if (hashEl) hashEl.textContent = hash;
                if (attemptsEl) attemptsEl.textContent = attempts;
                
                const elapsed = (Date.now() - startTime) / 1000;
                if (timeEl) timeEl.textContent = elapsed.toFixed(1) + 's';
                
                attempts++;
                
                // Check if hash starts with zeros (simplified - real Bitcoin needs many more)
                if (hash.startsWith('00')) {
                    mining = false;
                    mineBtn.textContent = '🎉 Block Mined!';
                    mineBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');
                    mineBtn.classList.add('bg-green-500');
                    if (hashEl) hashEl.parentElement.classList.add('bg-green-100');
                } else {
                    setTimeout(mine, 50); // Slow down for visualization
                }
            }
            
            mineBtn.addEventListener('click', () => {
                if (!mining) {
                    mining = true;
                    attempts = 0;
                    startTime = Date.now();
                    mineBtn.textContent = 'Mining...';
                    mineBtn.classList.add('bg-yellow-600');
                    if (hashEl) hashEl.parentElement.classList.remove('bg-green-100');
                    mine();
                }
            });
        })();

        // Lazy loading for charts (when Chart.js is available)
        const chartObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && window.Chart) {
                    // Initialize charts here when they become visible
                    chartObserver.unobserve(entry.target);
                }
            });
        }, { rootMargin: '200px' });

        // Observe canvas elements when they're added
        document.querySelectorAll('canvas').forEach(canvas => {
            chartObserver.observe(canvas);
        });

        // Lightning Routing Path Simulator
        /**
         * Simple Lightning route finder:
         * - Nodes: A(sender), B, C, D, F, R(receiver)
         * - Directed edges with: capacity (sats), baseFee (sats), ppm (parts per million)
         * - We try to find a path within capacity and total fees <= maxFee.
         * - If "Try Alt Paths" checked, we explore multiple simple paths (DFS limited depth).
         */
        (function(){
          const edges = [
            // from, to, capacity, base, ppm
            ['A','B', 20000, 1, 200], // 0.02% ppm ~ 200 ppm
            ['B','R', 12000, 1, 50],
            ['A','C',  9000,  1, 100],
            ['C','R',  9000,  1, 50],
            ['A','D', 30000,  1, 300],
            ['D','F', 30000,  1, 150],
            ['F','R', 30000,  1, 50],
            ['B','C',  8000,  1, 120],
            ['C','B',  5000,  1, 120],
          ];

          // Render edge list
          const list = document.getElementById('ln-edges');
          if(list){
            list.innerHTML = edges.map(([u,v,cap,base,ppm]) =>
              `<li>${u} → ${v} : ${cap.toLocaleString()} sats • fee: base ${base} + ${ppm}ppm</li>`
            ).join('');
          }

          function feeForHop(amount, base, ppm){
            // fee = base + (amount * ppm / 1e6)
            return base + Math.ceil(amount * (ppm/1e6));
          }

          // Small DFS to a depth of 5 to find simple paths A -> R
          function findPaths(graph, start, goal, maxDepth=5){
            const out = [];
            function dfs(node, path, visited){
              if(path.length > maxDepth) return;
              if(node === goal){ out.push(path.slice()); return; }
              for(const e of graph){
                const [u,v] = e;
                if(u!==node) continue;
                // prevent simple cycles
                if(visited.has(v)) continue;
                visited.add(v);
                path.push(e);
                dfs(v, path, visited);
                path.pop();
                visited.delete(v);
              }
            }
            dfs(start, [], new Set([start]));
            // produce node-path form, e.g., [A→B,B→R] => nodes [A,B,R]
            return out;
          }

          // Evaluate a path for capacity + fees (forward)
          function tryPath(path, amount, maxFee){
            let running = amount;
            let totalFee = 0;
            for(const [, , cap, base, ppm] of path){
              if(cap < running) return {ok:false, reason:`Insufficient capacity on hop requiring ${running} sats (cap ${cap})`};
              const hopFee = feeForHop(running, base, ppm);
              totalFee += hopFee;
              running += hopFee; // amount grows as you include fees forward
              if(totalFee > maxFee) return {ok:false, reason:`Fees exceed max (${totalFee} > ${maxFee})`};
            }
            return {ok:true, totalFee, finalSend: running};
          }

          function uniqueSimplePaths(all){
            // Dedup by node sequence
            const seen = new Set();
            const out = [];
            for(const p of all){
              const nodes = [p[0][0], ...p.map(e=>e[1])].join('→');
              if(!seen.has(nodes)){ seen.add(nodes); out.push(p); }
            }
            return out;
          }

          function chooseFirstFeasible(paths, amount, maxFee){
            for(const p of paths){
              const check = tryPath(p, amount, maxFee);
              if(check.ok) return {path:p, ...check};
            }
            return null;
          }

          // Wire UI
          const btn = document.getElementById('ln-send');
          const amountEl = document.getElementById('ln-amount');
          const maxFeeEl = document.getElementById('ln-maxfee');
          const altEl = document.getElementById('ln-try-alt');
          const resultWrap = document.getElementById('ln-result');
          const resultBox  = document.getElementById('ln-result-box');
          const resultTitle= document.getElementById('ln-result-title');
          const resultBody = document.getElementById('ln-result-body');

          btn?.addEventListener('click', ()=>{
            const amt = Math.max(1, parseInt(amountEl.value||'1',10));
            const maxFee = Math.max(0, parseInt(maxFeeEl.value||'0',10));
            const allPaths = findPaths(edges, 'A', 'R', 5);
            const candidatePaths = altEl.checked ? uniqueSimplePaths(allPaths) : uniqueSimplePaths(allPaths).slice(0,3);

            const feasible = chooseFirstFeasible(candidatePaths, amt, maxFee);

            resultWrap.classList.remove('hidden');
            if(!feasible){
              resultBox.className = "p-4 rounded border-l-4 border-red-500 bg-red-50";
              resultTitle.textContent = "Payment Failed";
              resultBody.innerHTML = `
                No route found within capacity/fee constraints.
                <div class="mt-2 text-xs text-gray-700">
                  Tips: lower amount, raise max fee, or enable alternate paths.
                </div>`;
              return;
            }

            const {path, totalFee, finalSend} = feasible;
            const nodes = ['A', ...path.map(([u,v])=>v)].join(' → ');
            const hops  = path.length;

            resultBox.className = "p-4 rounded border-l-4 border-green-500 bg-green-50";
            resultTitle.textContent = "Payment Succeeded";
            resultBody.innerHTML = `
              <div><span class="font-semibold">Route:</span> ${nodes} (${hops} hop${hops>1?'s':''})</div>
              <div><span class="font-semibold">Send:</span> ${amt.toLocaleString()} sats</div>
              <div><span class="font-semibold">Total fees:</span> ${totalFee.toLocaleString()} sats</div>
              <div><span class="font-semibold">Total forwarded (incl. fees):</span> ${finalSend.toLocaleString()} sats</div>
              <div class="text-xs text-gray-600 mt-2">Fees and capacities are illustrative. Real routing considers CLTV, HTLC limits, inbound/outbound liquidity, etc.</div>
            `;
          });
        })();

        // Merkle Proof Visualizer
        /**
         * Merkle demo (illustrative, not real SHA-256).
         * - Build a full binary tree (duplicate last leaf if odd).
         * - Click a leaf to display its proof (siblings up the tree).
         * - Verify by recomputing upward to the root.
         */
        (function(){
          const txUl = document.getElementById('merkle-txs');
          const treeDiv = document.getElementById('merkle-tree');
          const proofDiv = document.getElementById('merkle-proof');
          const verifyDiv = document.getElementById('merkle-verify');
          const shuffleBtn = document.getElementById('merkle-shuffle');
          if(!txUl) return;

          // deterministic pseudo-hash so UI is stable
          function phash(s){
            let h = 2166136261>>>0;
            for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
            return ('00000000'+(h>>>0).toString(16)).slice(-8);
          }
          const H = (a,b) => phash(a+b);

          let txs = [
            'Alice→Bob 1.2', 'Bob→Carol 0.3', 'Carol→Dave 0.05', 'Dave→Eve 0.2',
            'Zed→Mallory 0.8', 'Frank→Grace 0.01', 'Heidi→Ivan 0.6', 'Judy→Ken 0.42'
          ];

          function renderTxList(){
            txUl.innerHTML = '';
            txs.forEach((t,i)=>{
              const li = document.createElement('li');
              li.className = 'p-2 rounded border hover:bg-gray-50 cursor-pointer flex justify-between';
              li.innerHTML = `<span>${t}</span><span class="font-mono text-gray-600">${phash(t)}</span>`;
              li.setAttribute('tabindex','0');
              li.setAttribute('role','button');
              li.addEventListener('click', ()=>selectLeaf(i));
              li.addEventListener('keydown', e => {
                if(e.key==='Enter'||e.key===' '){ e.preventDefault(); li.click(); }
              });
              txUl.appendChild(li);
            });
          }

          function buildLeaves(){
            return txs.map(t => ({label:t, hash: phash(t)}));
          }

          function padToPowerOfTwo(leaves){
            const out = leaves.slice();
            while(out.length % 2 !== 0) out.push(out[out.length-1]); // duplicate last
            return out;
          }

          function buildTree(){
            const layers = [];
            let current = padToPowerOfTwo(buildLeaves());
            layers.push(current);
            while(current.length > 1){
              const next = [];
              for(let i=0;i<current.length;i+=2){
                const left = current[i], right = current[i+1];
                next.push({hash: H(left.hash, right.hash), left, right});
              }
              layers.push(next);
              current = next;
            }
            return layers; // layers[0] = leaves, last = root layer (length 1)
          }

          function renderTree(layers){
            treeDiv.innerHTML = '';
            layers.forEach((layer, idx)=>{
              const row = document.createElement('div');
              row.className = 'flex flex-wrap gap-2 items-start';
              row.innerHTML = `<div class="w-full text-gray-500 mb-1">Layer ${idx} ${idx===0?'(leaves)':''}</div>`;
              layer.forEach(n=>{
                const box = document.createElement('div');
                box.className = 'px-2 py-1 border rounded bg-white';
                box.innerHTML = `<div class="font-mono">${n.hash}</div>`;
                row.appendChild(box);
              });
              treeDiv.appendChild(row);
            });
          }

          function proofForIndex(layers, leafIndex){
            const proof = [];
            let idx = leafIndex;
            for(let layer=0; layer<layers.length-1; layer++){
              const isRight = idx % 2 === 1;
              const sibling = isRight ? idx-1 : idx+1;
              proof.push({pos: isRight?'L':'R', hash: layers[layer][sibling].hash});
              idx = Math.floor(idx/2);
            }
            return proof; // from leaf layer up to (but not including) root
          }

          function verifyProof(leafHash, proof, root){
            let acc = leafHash;
            for(const p of proof){
              acc = (p.pos==='L') ? H(p.hash, acc) : H(acc, p.hash);
            }
            return acc === root;
          }

          let layers = buildTree();
          renderTxList();
          renderTree(layers);

          function selectLeaf(i){
            layers = buildTree(); // rebuild (in case shuffled)
            const leafHash = layers[0][i].hash;
            const rootHash = layers[layers.length-1][0].hash;
            const proof = proofForIndex(layers, i);

            proofDiv.innerHTML = '';
            proof.forEach((p, idx)=>{
              const row = document.createElement('div');
              row.className = 'flex justify-between items-center border rounded px-2 py-1';
              row.innerHTML = `<div>Step ${idx+1}: ${p.pos==='L'?'Left':'Right'} sibling</div><div class="font-mono">${p.hash}</div>`;
              proofDiv.appendChild(row);
            });

            const ok = verifyProof(leafHash, proof, rootHash);
            verifyDiv.className = ok ? 'mt-3 text-green-700' : 'mt-3 text-red-700';
            verifyDiv.innerHTML = `
              <div class="flex items-center">
                <svg class="w-5 h-5 mr-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  ${ok ? '<path d="M9 12l2 2 4-4"/><circle cx="12" cy="12" r="10"/>' : '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>'}
                </svg>
                ${ok ? 'Proof valid: recomputed root matches' : 'Proof invalid'}
              </div>
              <div class="text-xs text-gray-600 mt-1"><span class="font-mono">leaf:</span> ${leafHash} • <span class="font-mono">root:</span> ${rootHash}</div>
            `;
          }

          shuffleBtn?.addEventListener('click', ()=>{
            // Fisher-Yates
            for(let i=txs.length-1;i>0;i--){
              const j = Math.floor(Math.random()*(i+1));
              [txs[i], txs[j]] = [txs[j], txs[i]];
            }
            renderTxList();
            layers = buildTree();
            renderTree(layers);
            proofDiv.innerHTML = '';
            verifyDiv.innerHTML = '';
          });
        })();
    </script>
</body>
</html>
